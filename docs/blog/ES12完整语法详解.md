# ES12 (ES2021) 完整语法详解

> ECMAScript 2021 (ES12) 引入了逻辑赋值运算符、字符串替换增强、数字分隔符、Promise增强等实用特性。
<div class="doc-toc">
## 目录

1. [逻辑赋值运算符](#1-逻辑赋值运算符)
2. [String.prototype.replaceAll()](#2-stringprototypereplaceall)
3. [数字分隔符](#3-数字分隔符)
4. [Promise.any()](#4-promiseany)
5. [WeakRefs和FinalizationRegistry](#5-weakrefs和finalizationregistry)
6. [AggregateError](#6-aggregateerror)


</div>

---

## 1. 逻辑赋值运算符

### 1.1 逻辑或赋值 (||=)

只有当左侧值为 falsy 时才赋值。

```javascript
// 基本用法
let a = null;
a ||= 'default';
console.log(a); // 'default'

let b = 'value';
b ||= 'default';
console.log(b); // 'value'

// 等价于
// a = a || 'default';
// 或
// if (!a) a = 'default';

// falsy值都会触发赋值
let x = 0;
x ||= 10;
console.log(x); // 10 (因为0是falsy)

let y = '';
y ||= 'empty';
console.log(y); // 'empty' (因为''是falsy)
```

### 1.2 逻辑与赋值 (&&=)

只有当左侧值为 truthy 时才赋值。

```javascript
// 基本用法
let a = 1;
a &&= 2;
console.log(a); // 2

let b = null;
b &&= 2;
console.log(b); // null (因为null是falsy，不赋值)

// 等价于
// a = a && 2;
// 或
// if (a) a = 2;

// 实际应用：条件更新
let user = {
  name: '张三',
  age: 25
};

user.name &&= user.name.toUpperCase();
console.log(user.name); // '张三' (中文不变)

user.email &&= user.email.toLowerCase();
console.log(user.email); // undefined (不存在，不赋值)
```

### 1.3 空值合并赋值 (??=)

只有当左侧值为 null 或 undefined 时才赋值。

```javascript
// 基本用法
let a = null;
a ??= 'default';
console.log(a); // 'default'

let b = undefined;
b ??= 'default';
console.log(b); // 'default'

// 0、''、false 不会触发赋值
let c = 0;
c ??= 10;
console.log(c); // 0 (保持原值)

let d = '';
d ??= 'empty';
console.log(d); // '' (保持原值)

let e = false;
e ??= true;
console.log(e); // false (保持原值)
```

### 1.4 实际应用场景

#### 场景1：默认配置

```javascript
const config = {
  timeout: 0,        // 故意设为0
  debug: false,      // 故意设为false
  apiUrl: null,      // 需要默认值
  retries: undefined // 需要默认值
};

// 使用 ??= 设置默认值（保留0和false）
config.timeout ??= 5000;   // 保持0
config.debug ??= true;     // 保持false
config.apiUrl ??= '/api';  // 设为'/api'
config.retries ??= 3;      // 设为3

console.log(config);
// { timeout: 0, debug: false, apiUrl: '/api', retries: 3 }
```

#### 场景2：惰性初始化

```javascript
class Cache {
  constructor() {
    this.store = {};
  }
  
  get(key) {
    // 惰性初始化
    this.store[key] ??= this.loadFromStorage(key);
    return this.store[key];
  }
  
  loadFromStorage(key) {
    console.log(`从存储加载: ${key}`);
    return { data: `value_${key}` };
  }
}

const cache = new Cache();
console.log(cache.get('user')); // 从存储加载: user
console.log(cache.get('user')); // 直接返回缓存，不再加载
```

#### 场景3：对象属性初始化

```javascript
// 分组数据
const data = [
  { category: 'A', value: 1 },
  { category: 'B', value: 2 },
  { category: 'A', value: 3 },
  { category: 'B', value: 4 }
];

const grouped = {};

data.forEach(item => {
  // 初始化数组
  grouped[item.category] ??= [];
  grouped[item.category].push(item.value);
});

console.log(grouped);
// { A: [1, 3], B: [2, 4] }
```

#### 场景4：条件更新

```javascript
// 只在有值时更新
function updateUser(userId, updates) {
  const user = getUser(userId);
  
  // 只有当updates中有对应字段时才更新
  user.name &&= updates.name || user.name;
  user.email &&= updates.email || user.email;
  user.age &&= updates.age || user.age;
  
  return user;
}

// 更安全的写法
function updateUserSafe(userId, updates) {
  const user = getUser(userId);
  
  // 使用 && 确保字段存在时才处理
  updates.name && (user.name = updates.name);
  updates.email && (user.email = updates.email.toLowerCase());
  
  return user;
}
```

#### 场景5：DOM元素缓存

```javascript
class Component {
  constructor() {
    this._elementCache = {};
  }
  
  getElement(selector) {
    // 惰性获取并缓存DOM元素
    this._elementCache[selector] ??= document.querySelector(selector);
    return this._elementCache[selector];
  }
  
  onClick() {
    const btn = this.getElement('#submit-btn');
    const form = this.getElement('#my-form');
    // ...
  }
}
```

---

## 2. String.prototype.replaceAll()

### 2.1 基本语法

`replaceAll()` 替换字符串中所有匹配项。

```javascript
// 基本用法
const str = 'hello world, hello javascript';

// replace只替换第一个
console.log(str.replace('hello', 'hi'));
// 'hi world, hello javascript'

// replaceAll替换所有
console.log(str.replaceAll('hello', 'hi'));
// 'hi world, hi javascript'

// 之前需要使用正则
console.log(str.replace(/hello/g, 'hi'));
// 'hi world, hi javascript'
```

### 2.2 使用正则表达式

```javascript
// 使用正则必须带g标志
const str = 'a1b2c3';

console.log(str.replaceAll(/\d/g, '*'));
// 'a*b*c*'

// 不带g标志会报错
// str.replaceAll(/\d/, '*'); // TypeError
```

### 2.3 实际应用场景

#### 场景1：模板替换

```javascript
function render(template, data) {
  let result = template;
  
  for (const [key, value] of Object.entries(data)) {
    result = result.replaceAll(`{{${key}}}`, value);
  }
  
  return result;
}

const template = '{{name}}你好，你的订单{{orderId}}已发货，预计{{date}}送达。';

console.log(render(template, {
  name: '张三',
  orderId: 'ORD123456',
  date: '2026-02-05'
}));
// '张三你好，你的订单ORD123456已发货，预计2026-02-05送达。'
```

#### 场景2：HTML转义

```javascript
function escapeHtml(str) {
  return str
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

const userInput = '<script>alert("XSS")</script>';
console.log(escapeHtml(userInput));
// '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;'

// 反转义
function unescapeHtml(str) {
  return str
    .replaceAll('&amp;', '&')
    .replaceAll('&lt;', '<')
    .replaceAll('&gt;', '>')
    .replaceAll('&quot;', '"')
    .replaceAll('&#39;', "'");
}
```

#### 场景3：路径处理

```javascript
// 规范化路径分隔符
function normalizePath(path) {
  return path
    .replaceAll('\\', '/')
    .replaceAll('//', '/');
}

console.log(normalizePath('C:\\Users\\admin\\Documents'));
// 'C:/Users/admin/Documents'

console.log(normalizePath('/path//to///file'));
// '/path/to/file' (需要多次调用或用正则)
```

#### 场景4：文本清理

```javascript
// 清理多余空格
function cleanText(text) {
  return text
    .replaceAll('\t', ' ')
    .replaceAll('\n', ' ')
    .replaceAll('  ', ' ')
    .trim();
}

// 敏感词过滤
const sensitiveWords = ['敏感词1', '敏感词2', '敏感词3'];

function filterSensitive(text) {
  let result = text;
  for (const word of sensitiveWords) {
    result = result.replaceAll(word, '*'.repeat(word.length));
  }
  return result;
}

console.log(filterSensitive('这里有敏感词1和敏感词2'));
// '这里有****和****'
```

#### 场景5：URL处理

```javascript
// 编码特殊字符
function encodeUrl(url) {
  return url
    .replaceAll(' ', '%20')
    .replaceAll('&', '%26')
    .replaceAll('?', '%3F');
}

// 查询参数处理
function addQueryParams(url, params) {
  let result = url;
  const queryString = Object.entries(params)
    .map(([key, value]) => `${key}=${value}`)
    .join('&');
  
  return url.includes('?')
    ? `${url}&${queryString}`
    : `${url}?${queryString}`;
}
```

---

## 3. 数字分隔符

### 3.1 基本语法

使用下划线 `_` 作为数字分隔符，提高可读性。

```javascript
// 十进制
const billion = 1_000_000_000;
console.log(billion); // 1000000000

const price = 99_99; // 99.99元（分）
console.log(price); // 9999

// 二进制
const binary = 0b1010_0101_1001_0110;
console.log(binary); // 42390

// 十六进制
const hex = 0xFF_EC_DE_5E;
console.log(hex); // 4293713502

// 八进制
const octal = 0o755_744;
console.log(octal); // 252900

// BigInt
const bigNum = 9_007_199_254_740_991n;
console.log(bigNum); // 9007199254740991n
```

### 3.2 注意事项

```javascript
// 不能放在开头或结尾
// const a = _1000; // 语法错误
// const b = 1000_; // 语法错误

// 不能连续使用
// const c = 1__000; // 语法错误

// 不能放在小数点旁边
// const d = 1_.0; // 语法错误
// const e = 1._0; // 语法错误

// 正确的小数用法
const decimal = 3.141_592_653;
console.log(decimal); // 3.141592653
```

### 3.3 实际应用场景

```javascript
// 场景1：金额（以分为单位）
const priceInCents = 1_299_99; // ¥12999.99
const discountedPrice = 999_99; // ¥9999.99

// 场景2：文件大小
const KB = 1_024;
const MB = 1_048_576;
const GB = 1_073_741_824;

// 场景3：时间（毫秒）
const SECOND = 1_000;
const MINUTE = 60_000;
const HOUR = 3_600_000;
const DAY = 86_400_000;

// 场景4：颜色值
const red = 0xFF_00_00;
const green = 0x00_FF_00;
const blue = 0x00_00_FF;
const white = 0xFF_FF_FF;

// 场景5：权限位
const READ = 0b100;
const WRITE = 0b010;
const EXECUTE = 0b001;
const ALL_PERMISSIONS = 0b111;

// 场景6：电话号码（纯数字）
const phonePattern = 138_1234_5678;

// 场景7：科学计数
const speedOfLight = 299_792_458; // m/s
const earthRadius = 6_371_000; // meters
```

---

## 4. Promise.any()

### 4.1 基本语法

`Promise.any()` 返回第一个成功的Promise结果。

```javascript
// 基本用法
const promises = [
  Promise.reject('错误1'),
  Promise.resolve('成功1'),
  Promise.resolve('成功2')
];

const result = await Promise.any(promises);
console.log(result); // '成功1' (第一个成功的)

// 所有都失败时抛出AggregateError
const allFail = [
  Promise.reject('错误1'),
  Promise.reject('错误2'),
  Promise.reject('错误3')
];

try {
  await Promise.any(allFail);
} catch (error) {
  console.log(error instanceof AggregateError); // true
  console.log(error.errors); // ['错误1', '错误2', '错误3']
}
```

### 4.2 与其他Promise方法对比

```javascript
// Promise.all - 全部成功才成功，一个失败就失败
// Promise.race - 最快的结果（无论成功失败）
// Promise.allSettled - 等待全部完成，返回所有结果
// Promise.any - 第一个成功的，全失败才失败

const fast = new Promise(r => setTimeout(() => r('fast'), 100));
const slow = new Promise(r => setTimeout(() => r('slow'), 200));
const fail = new Promise((_, reject) => setTimeout(() => reject('fail'), 50));

// Promise.race - 返回最快的（可能是失败）
Promise.race([fast, slow, fail])
  .then(console.log)
  .catch(console.error); // 'fail'

// Promise.any - 返回第一个成功的
Promise.any([fast, slow, fail])
  .then(console.log)
  .catch(console.error); // 'fast'
```

### 4.3 实际应用场景

#### 场景1：多源数据获取

```javascript
// 从多个CDN获取资源
async function fetchFromCDN(resource) {
  const cdns = [
    `https://cdn1.example.com/${resource}`,
    `https://cdn2.example.com/${resource}`,
    `https://cdn3.example.com/${resource}`
  ];
  
  try {
    const response = await Promise.any(
      cdns.map(url => fetch(url))
    );
    return response;
  } catch (error) {
    throw new Error('所有CDN都不可用');
  }
}
```

#### 场景2：服务降级

```javascript
// 尝试多个服务，使用第一个成功的
async function getWeather(city) {
  const services = [
    () => fetch(`https://api1.weather.com/${city}`),
    () => fetch(`https://api2.weather.com/${city}`),
    () => fetch(`https://api3.weather.com/${city}`)
  ];
  
  try {
    const response = await Promise.any(
      services.map(service => service())
    );
    return response.json();
  } catch {
    return { error: '无法获取天气数据' };
  }
}
```

#### 场景3：超时处理

```javascript
// 带超时的请求
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('超时')), timeout);
  });
  
  // 这里用race更合适，但演示any的用法
  return Promise.any([fetchPromise])
    .catch(() => {
      throw new Error('请求失败');
    });
}

// 竞速请求
async function fastestResponse(urls) {
  const requests = urls.map(url => 
    fetch(url).then(r => ({ url, data: r }))
  );
  
  const fastest = await Promise.any(requests);
  console.log(`最快响应来自: ${fastest.url}`);
  return fastest.data;
}
```

#### 场景4：数据库连接

```javascript
// 尝试连接到多个数据库副本
async function connectToDatabase() {
  const replicas = [
    'mongodb://replica1:27017',
    'mongodb://replica2:27017',
    'mongodb://replica3:27017'
  ];
  
  try {
    const connection = await Promise.any(
      replicas.map(uri => connectToMongo(uri))
    );
    console.log('成功连接到数据库');
    return connection;
  } catch (error) {
    console.error('无法连接到任何数据库副本');
    throw error;
  }
}
```

---

## 5. WeakRefs和FinalizationRegistry

### 5.1 WeakRef基本概念

`WeakRef` 创建对象的弱引用，不会阻止垃圾回收。

```javascript
// 创建弱引用
let obj = { name: '张三' };
const weakRef = new WeakRef(obj);

// 获取引用的对象（可能返回undefined）
console.log(weakRef.deref()); // { name: '张三' }

// 原对象被回收后
obj = null;
// 某个时间点后...
console.log(weakRef.deref()); // undefined (已被回收)
```

### 5.2 FinalizationRegistry

`FinalizationRegistry` 在对象被垃圾回收时执行回调。

```javascript
// 创建注册表
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`对象被回收了，持有值: ${heldValue}`);
});

// 注册对象
let obj = { data: 'important' };
registry.register(obj, 'my-object-identifier');

// 当obj被回收时，会执行回调
obj = null;
// 稍后会看到: "对象被回收了，持有值: my-object-identifier"
```

### 5.3 实际应用场景

#### 场景1：缓存

```javascript
class Cache {
  constructor() {
    this._cache = new Map();
    this._registry = new FinalizationRegistry((key) => {
      console.log(`缓存项 ${key} 的值已被回收`);
      // 可选：清理Map中的条目
      if (this._cache.get(key)?.deref() === undefined) {
        this._cache.delete(key);
      }
    });
  }
  
  set(key, value) {
    const ref = new WeakRef(value);
    this._cache.set(key, ref);
    this._registry.register(value, key);
  }
  
  get(key) {
    const ref = this._cache.get(key);
    if (ref) {
      const value = ref.deref();
      if (value !== undefined) {
        return value;
      }
      // 值已被回收，清理
      this._cache.delete(key);
    }
    return undefined;
  }
  
  has(key) {
    return this.get(key) !== undefined;
  }
}

const cache = new Cache();

let largeObject = { data: new Array(1000000).fill('x') };
cache.set('large', largeObject);

console.log(cache.has('large')); // true

// 允许被回收
largeObject = null;
// 触发GC后
// console.log(cache.has('large')); // 可能是false
```

#### 场景2：资源清理

```javascript
class ResourceManager {
  constructor() {
    this._resources = new Map();
    this._registry = new FinalizationRegistry((resourceId) => {
      console.log(`清理资源: ${resourceId}`);
      this.cleanup(resourceId);
    });
  }
  
  allocate(id, resource) {
    const wrapper = { resource };
    this._resources.set(id, new WeakRef(wrapper));
    this._registry.register(wrapper, id);
    return wrapper;
  }
  
  cleanup(id) {
    // 清理关联的系统资源
    console.log(`释放资源 ${id} 的系统句柄`);
    this._resources.delete(id);
  }
  
  get(id) {
    return this._resources.get(id)?.deref()?.resource;
  }
}
```

#### 场景3：观察者模式

```javascript
class Observable {
  constructor() {
    this._observers = new Set();
    this._registry = new FinalizationRegistry((observer) => {
      this._observers.delete(observer);
      console.log('观察者已被回收并移除');
    });
  }
  
  subscribe(observer) {
    const ref = new WeakRef(observer);
    this._observers.add(ref);
    this._registry.register(observer, ref);
    
    // 返回取消订阅函数
    return () => {
      this._observers.delete(ref);
    };
  }
  
  notify(data) {
    for (const ref of this._observers) {
      const observer = ref.deref();
      if (observer) {
        observer.update(data);
      } else {
        // 清理已回收的引用
        this._observers.delete(ref);
      }
    }
  }
}
```

### 5.4 注意事项

```javascript
// 警告：WeakRef和FinalizationRegistry应该谨慎使用

// 1. 不保证回调何时执行（甚至可能不执行）
// 2. 不应该用于关键业务逻辑
// 3. 主要用于缓存、日志等非关键场景

// 正确用法示例
class ImageCache {
  constructor() {
    this._cache = new Map();
  }
  
  get(url) {
    const ref = this._cache.get(url);
    if (ref) {
      const image = ref.deref();
      if (image) return image;
      // 已回收，从缓存移除
      this._cache.delete(url);
    }
    return null;
  }
  
  set(url, image) {
    this._cache.set(url, new WeakRef(image));
  }
}
```

---

## 6. AggregateError

### 6.1 基本概念

`AggregateError` 用于表示多个错误的集合。

```javascript
// 创建AggregateError
const errors = [
  new Error('错误1'),
  new Error('错误2'),
  new Error('错误3')
];

const aggregateError = new AggregateError(errors, '多个操作失败');

console.log(aggregateError.message); // '多个操作失败'
console.log(aggregateError.errors);  // [Error, Error, Error]

// 遍历错误
for (const error of aggregateError.errors) {
  console.log(error.message);
}
```

### 6.2 与Promise.any配合

```javascript
// Promise.any全部失败时抛出AggregateError
async function tryMultipleSources() {
  try {
    await Promise.any([
      Promise.reject(new Error('源1失败')),
      Promise.reject(new Error('源2失败')),
      Promise.reject(new Error('源3失败'))
    ]);
  } catch (error) {
    if (error instanceof AggregateError) {
      console.log('所有源都失败了:');
      error.errors.forEach((e, i) => {
        console.log(`  源${i + 1}: ${e.message}`);
      });
    }
  }
}

tryMultipleSources();
// 所有源都失败了:
//   源1: 源1失败
//   源2: 源2失败
//   源3: 源3失败
```

### 6.3 实际应用场景

#### 场景1：批量验证

```javascript
function validateUser(user) {
  const errors = [];
  
  if (!user.name || user.name.length < 2) {
    errors.push(new Error('姓名至少2个字符'));
  }
  
  if (!user.email || !user.email.includes('@')) {
    errors.push(new Error('邮箱格式不正确'));
  }
  
  if (!user.age || user.age < 0 || user.age > 150) {
    errors.push(new Error('年龄必须在0-150之间'));
  }
  
  if (errors.length > 0) {
    throw new AggregateError(errors, '用户验证失败');
  }
  
  return true;
}

try {
  validateUser({ name: '', email: 'invalid', age: -1 });
} catch (error) {
  if (error instanceof AggregateError) {
    console.log('验证错误:');
    error.errors.forEach(e => console.log(`- ${e.message}`));
  }
}
```

#### 场景2：批量操作错误收集

```javascript
async function batchUpdate(items, updateFn) {
  const results = await Promise.allSettled(
    items.map(item => updateFn(item))
  );
  
  const errors = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
  
  const successes = results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
  
  if (errors.length > 0) {
    const aggregateError = new AggregateError(
      errors,
      `${errors.length}/${items.length} 项更新失败`
    );
    aggregateError.successes = successes;
    throw aggregateError;
  }
  
  return successes;
}

// 使用
try {
  await batchUpdate([1, 2, 3, 4, 5], async (id) => {
    if (id === 3) throw new Error(`更新 ${id} 失败`);
    return { id, updated: true };
  });
} catch (error) {
  if (error instanceof AggregateError) {
    console.log(error.message);
    console.log('成功的项:', error.successes);
    console.log('失败详情:', error.errors);
  }
}
```

#### 场景3：并行任务错误处理

```javascript
class TaskRunner {
  constructor() {
    this.tasks = [];
  }
  
  addTask(task) {
    this.tasks.push(task);
    return this;
  }
  
  async runAll() {
    const results = await Promise.allSettled(
      this.tasks.map(task => task())
    );
    
    const errors = [];
    const values = [];
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        values.push({ index, value: result.value });
      } else {
        errors.push({ index, error: result.reason });
      }
    });
    
    if (errors.length > 0 && errors.length === this.tasks.length) {
      throw new AggregateError(
        errors.map(e => e.error),
        '所有任务都失败了'
      );
    }
    
    return { values, errors };
  }
}

// 使用
const runner = new TaskRunner()
  .addTask(async () => 'task1 success')
  .addTask(async () => { throw new Error('task2 failed'); })
  .addTask(async () => 'task3 success');

const { values, errors } = await runner.runAll();
console.log('成功:', values);
console.log('失败:', errors);
```

---

## 总结

ES12 (ES2021) 的主要新特性：

### 逻辑赋值运算符
- `||=`：falsy时赋值
- `&&=`：truthy时赋值
- `??=`：null/undefined时赋值
- 简化条件赋值代码

### String.prototype.replaceAll()
- 替换所有匹配项
- 无需使用正则的g标志
- 简化字符串处理

### 数字分隔符
- 使用 `_` 分隔数字
- 提高大数可读性
- 支持所有进制

### Promise.any()
- 返回第一个成功的Promise
- 全失败时抛出AggregateError
- 适合多源竞争场景

### WeakRefs和FinalizationRegistry
- WeakRef创建弱引用
- FinalizationRegistry监听对象回收
- 用于缓存等非关键场景

### AggregateError
- 表示多个错误的集合
- 与Promise.any配合使用
- 适合批量操作错误处理

这些特性进一步提升了JavaScript的开发体验和代码简洁性，特别是在处理异步操作和字符串操作方面。
