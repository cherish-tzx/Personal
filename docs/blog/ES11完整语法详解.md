# ES11 (ES2020) 完整语法详解

> ECMAScript 2020 (ES11) 引入了可选链、空值合并、BigInt、动态导入等重要特性。
<div class="doc-toc">
## 目录

1. [可选链操作符 (?.)](#1-可选链操作符-)
2. [空值合并操作符 (??)](#2-空值合并操作符-)
3. [BigInt](#3-bigint)
4. [动态导入 import()](#4-动态导入-import)
5. [Promise.allSettled()](#5-promiseallsettled)
6. [globalThis](#6-globalthis)
7. [String.prototype.matchAll()](#7-stringprototypematchall)
8. [for-in顺序](#8-for-in顺序)
9. [import.meta](#9-importmeta)
10. [export * as ns from 'module'](#10-export--as-ns-from-module)


</div>

---

## 1. 可选链操作符 (?.)

### 1.1 基本语法

可选链操作符允许安全地访问嵌套对象属性，如果中间属性为 `null` 或 `undefined`，表达式短路返回 `undefined`。

```javascript
// 属性访问
const user = {
  name: '张三',
  address: {
    city: '北京'
  }
};

// 安全访问
console.log(user?.address?.city);     // '北京'
console.log(user?.contact?.phone);    // undefined (不会报错)

// 之前的写法
// user && user.address && user.address.city

// 数组访问
const arr = [1, 2, 3];
console.log(arr?.[0]); // 1
console.log(arr?.[10]); // undefined

// 函数调用
const obj = {
  greet: () => 'Hello'
};

console.log(obj.greet?.()); // 'Hello'
console.log(obj.sayBye?.()); // undefined (不会报错)
```

### 1.2 与函数调用结合

```javascript
// 可选的方法调用
const api = {
  user: {
    getName: () => '张三'
  }
};

console.log(api.user?.getName?.()); // '张三'
console.log(api.admin?.getName?.()); // undefined

// 回调函数
function fetchData(callback) {
  const data = { result: 'success' };
  callback?.(data); // 如果callback存在则调用
}

fetchData(); // 不会报错
fetchData(data => console.log(data)); // { result: 'success' }
```

### 1.3 实际应用场景

#### 场景1：处理API响应

```javascript
// API响应可能有不同结构
function handleResponse(response) {
  const userId = response?.data?.user?.id;
  const userName = response?.data?.user?.profile?.name ?? '未知用户';
  const avatar = response?.data?.user?.profile?.avatar ?? '/default-avatar.png';
  
  return { userId, userName, avatar };
}

// 正常响应
console.log(handleResponse({
  data: {
    user: {
      id: 1,
      profile: { name: '张三', avatar: '/avatar.png' }
    }
  }
}));

// 不完整响应
console.log(handleResponse({ data: {} }));
// { userId: undefined, userName: '未知用户', avatar: '/default-avatar.png' }

// 空响应
console.log(handleResponse(null));
// { userId: undefined, userName: '未知用户', avatar: '/default-avatar.png' }
```

#### 场景2：DOM操作

```javascript
// 安全的DOM查询
const button = document.querySelector('#submit-btn');
button?.addEventListener('click', handleClick);

// 获取元素属性
const inputValue = document.querySelector('#input')?.value;
const dataset = document.querySelector('.card')?.dataset?.id;

// 链式DOM操作
const text = document
  .querySelector('.container')
  ?.querySelector('.content')
  ?.textContent;
```

#### 场景3：配置对象

```javascript
function createServer(config) {
  const port = config?.server?.port ?? 3000;
  const host = config?.server?.host ?? 'localhost';
  const ssl = config?.server?.ssl?.enabled ?? false;
  const timeout = config?.server?.timeout ?? 5000;
  
  return { port, host, ssl, timeout };
}

// 完整配置
console.log(createServer({
  server: { port: 8080, host: '0.0.0.0' }
}));

// 空配置
console.log(createServer({}));
console.log(createServer(null));
```

#### 场景4：事件处理

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  emit(event, data) {
    // 使用可选链安全调用
    this.events[event]?.forEach(handler => handler(data));
  }
  
  on(event, handler) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(handler);
  }
}

const emitter = new EventEmitter();
emitter.emit('test', { data: 'hello' }); // 不会报错，即使没有监听器
```

#### 场景5：解析JSON

```javascript
function safeGet(obj, path, defaultValue) {
  const keys = path.split('.');
  let result = obj;
  
  for (const key of keys) {
    result = result?.[key];
    if (result === undefined) {
      return defaultValue;
    }
  }
  
  return result;
}

const data = {
  user: {
    profile: {
      name: '张三'
    }
  }
};

console.log(safeGet(data, 'user.profile.name', '未知')); // '张三'
console.log(safeGet(data, 'user.settings.theme', 'light')); // 'light'
```

---

## 2. 空值合并操作符 (??)

### 2.1 基本语法

空值合并操作符只在左侧为 `null` 或 `undefined` 时返回右侧值。

```javascript
// 基本用法
console.log(null ?? 'default');      // 'default'
console.log(undefined ?? 'default'); // 'default'
console.log('' ?? 'default');        // '' (空字符串不是null/undefined)
console.log(0 ?? 'default');         // 0
console.log(false ?? 'default');     // false

// 与 || 的区别
console.log('' || 'default');  // 'default' (空字符串是falsy)
console.log('' ?? 'default');  // ''
console.log(0 || 'default');   // 'default'
console.log(0 ?? 'default');   // 0
console.log(false || 'default'); // 'default'
console.log(false ?? 'default'); // false
```

### 2.2 与可选链结合

```javascript
const user = {
  name: '',
  age: 0,
  settings: null
};

// 使用 ?? 保留有意义的falsy值
console.log(user.name ?? '未命名');        // ''
console.log(user.age ?? 18);               // 0
console.log(user.settings?.theme ?? 'light'); // 'light'
console.log(user.nickname ?? '无昵称');    // '无昵称'
```

### 2.3 实际应用场景

#### 场景1：默认参数

```javascript
// 函数默认参数
function greet(name) {
  const displayName = name ?? 'Guest';
  console.log(`Hello, ${displayName}!`);
}

greet('张三');    // Hello, 张三!
greet('');        // Hello, !  (空字符串被保留)
greet(null);      // Hello, Guest!
greet(undefined); // Hello, Guest!
greet();          // Hello, Guest!

// 配置对象默认值
function createConfig(options = {}) {
  return {
    debug: options.debug ?? false,
    timeout: options.timeout ?? 5000,
    retries: options.retries ?? 3,
    baseUrl: options.baseUrl ?? '/api'
  };
}

console.log(createConfig({ timeout: 0 }));
// { debug: false, timeout: 0, retries: 3, baseUrl: '/api' }
// timeout是0而不是5000，因为0不是null/undefined
```

#### 场景2：表单处理

```javascript
function processFormData(formData) {
  return {
    username: formData.username ?? '',
    age: formData.age ?? null,
    newsletter: formData.newsletter ?? false,
    bio: formData.bio ?? ''
  };
}

// 用户没有填写某些字段
const rawData = {
  username: 'user123',
  age: 0,           // 用户输入了0岁
  newsletter: false  // 用户选择不订阅
};

console.log(processFormData(rawData));
// { username: 'user123', age: 0, newsletter: false, bio: '' }
// age和newsletter的falsy值被正确保留
```

#### 场景3：链式默认值

```javascript
// 多级默认值
function getConfig(env) {
  const configs = {
    production: { timeout: 3000 },
    development: { timeout: 10000 }
  };
  
  return configs[env]?.timeout ?? configs.production?.timeout ?? 5000;
}

console.log(getConfig('production'));  // 3000
console.log(getConfig('development')); // 10000
console.log(getConfig('staging'));     // 5000 (使用最终默认值)
```

#### 场景4：数据转换

```javascript
// 保留有意义的0值
const data = [
  { name: '商品A', discount: 0 },    // 无折扣
  { name: '商品B', discount: 0.1 },  // 9折
  { name: '商品C', discount: null }, // 未设置
  { name: '商品D' }                  // 未设置
];

const processed = data.map(item => ({
  ...item,
  discount: item.discount ?? 0.2 // 默认8折
}));

console.log(processed);
// [
//   { name: '商品A', discount: 0 },
//   { name: '商品B', discount: 0.1 },
//   { name: '商品C', discount: 0.2 },
//   { name: '商品D', discount: 0.2 }
// ]
```

### 2.4 赋值运算符 (??=)

```javascript
// 空值合并赋值
let a = null;
a ??= 'default';
console.log(a); // 'default'

let b = 'value';
b ??= 'default';
console.log(b); // 'value'

let c = '';
c ??= 'default';
console.log(c); // '' (空字符串不是null/undefined)

// 实际应用：惰性初始化
const cache = {};

function getOrCreate(key, creator) {
  cache[key] ??= creator();
  return cache[key];
}

console.log(getOrCreate('user', () => ({ id: 1 }))); // { id: 1 }
console.log(getOrCreate('user', () => ({ id: 2 }))); // { id: 1 } (已缓存)
```

---

## 3. BigInt

### 3.1 基本语法

BigInt 是一种可以表示任意精度整数的数据类型。

```javascript
// 创建BigInt
const big1 = 9007199254740991n; // 字面量
const big2 = BigInt(9007199254740991); // 函数
const big3 = BigInt('9007199254740991'); // 从字符串

// 超出Number安全范围
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(9007199254740992n);       // 9007199254740992n (精确)
console.log(9007199254740993n);       // 9007199254740993n (精确)

// Number会丢失精度
console.log(9007199254740992);  // 9007199254740992
console.log(9007199254740993);  // 9007199254740992 (丢失精度!)
```

### 3.2 BigInt运算

```javascript
// 基本运算
console.log(10n + 20n);  // 30n
console.log(10n - 5n);   // 5n
console.log(10n * 3n);   // 30n
console.log(10n / 3n);   // 3n (整数除法)
console.log(10n % 3n);   // 1n
console.log(2n ** 10n);  // 1024n

// 不能与Number混合运算
// console.log(10n + 5); // TypeError

// 需要显式转换
console.log(10n + BigInt(5)); // 15n
console.log(Number(10n) + 5); // 15

// 比较运算
console.log(10n > 5n);   // true
console.log(10n === 10); // false (类型不同)
console.log(10n == 10);  // true (值相等)
console.log(10n < 11);   // true (可以与Number比较)
```

### 3.3 实际应用场景

#### 场景1：大数计算

```javascript
// 计算大数阶乘
function factorial(n) {
  if (n <= 1n) return 1n;
  return n * factorial(n - 1n);
}

console.log(factorial(20n));
// 2432902008176640000n

console.log(factorial(50n));
// 30414093201713378043612608166064768844377641568960512000000000000n

// 精确的大整数运算
function fibonacci(n) {
  if (n <= 1n) return n;
  
  let prev = 0n;
  let current = 1n;
  
  for (let i = 2n; i <= n; i++) {
    [prev, current] = [current, prev + current];
  }
  
  return current;
}

console.log(fibonacci(100n));
// 354224848179261915075n
```

#### 场景2：处理数据库ID

```javascript
// 数据库中的大整数ID
const userId = 9223372036854775807n; // 最大的64位有符号整数

// 从API响应解析
function parseUserId(jsonResponse) {
  // JSON.parse无法正确解析大数
  const data = JSON.parse(jsonResponse);
  // 需要从字符串创建BigInt
  return BigInt(data.user_id);
}

// 发送时转为字符串
function stringifyBigInt(obj) {
  return JSON.stringify(obj, (key, value) =>
    typeof value === 'bigint' ? value.toString() : value
  );
}

console.log(stringifyBigInt({ userId: 9223372036854775807n }));
// '{"userId":"9223372036854775807"}'
```

#### 场景3：时间戳处理

```javascript
// 高精度时间戳（纳秒）
const nanoTimestamp = 1706860800000000000n; // 纳秒级时间戳

// 转换为毫秒
const msTimestamp = nanoTimestamp / 1000000n;
console.log(msTimestamp); // 1706860800000n

// 计算时间差（纳秒精度）
function measureNano(fn) {
  const start = process.hrtime.bigint();
  fn();
  const end = process.hrtime.bigint();
  return end - start;
}
```

#### 场景4：加密和哈希

```javascript
// 简单的大数模幂运算（用于加密）
function modPow(base, exponent, modulus) {
  let result = 1n;
  base = base % modulus;
  
  while (exponent > 0n) {
    if (exponent % 2n === 1n) {
      result = (result * base) % modulus;
    }
    exponent = exponent / 2n;
    base = (base * base) % modulus;
  }
  
  return result;
}

// RSA加密示例（简化版）
const message = 42n;
const e = 65537n; // 公钥指数
const n = 3233n;  // 模数

const encrypted = modPow(message, e, n);
console.log('加密后:', encrypted);
```

---

## 4. 动态导入 import()

### 4.1 基本语法

动态导入返回一个Promise，允许按需加载模块。

```javascript
// 动态导入模块
async function loadModule() {
  const module = await import('./myModule.js');
  module.doSomething();
}

// 或使用.then()
import('./myModule.js')
  .then(module => {
    module.doSomething();
  })
  .catch(err => {
    console.error('模块加载失败:', err);
  });

// 导入默认导出
const { default: MyClass } = await import('./MyClass.js');
```

### 4.2 实际应用场景

#### 场景1：按需加载

```javascript
// 路由懒加载
const routes = {
  '/home': () => import('./pages/Home.js'),
  '/about': () => import('./pages/About.js'),
  '/contact': () => import('./pages/Contact.js')
};

async function loadPage(path) {
  const loader = routes[path];
  if (!loader) {
    throw new Error('页面不存在');
  }
  
  const module = await loader();
  return module.default;
}

// 使用
loadPage('/home').then(HomePage => {
  // 渲染页面
});
```

#### 场景2：条件加载

```javascript
// 根据环境加载不同配置
async function loadConfig() {
  const env = process.env.NODE_ENV;
  
  if (env === 'production') {
    return import('./config/production.js');
  } else if (env === 'development') {
    return import('./config/development.js');
  } else {
    return import('./config/default.js');
  }
}

// 根据用户语言加载翻译
async function loadTranslations(locale) {
  try {
    const module = await import(`./locales/${locale}.js`);
    return module.default;
  } catch {
    // 回退到默认语言
    const fallback = await import('./locales/en.js');
    return fallback.default;
  }
}
```

#### 场景3：功能检测后加载

```javascript
// 检测特性后加载polyfill
async function initApp() {
  // 如果不支持某特性，加载polyfill
  if (!window.IntersectionObserver) {
    await import('intersection-observer');
  }
  
  if (!window.fetch) {
    await import('whatwg-fetch');
  }
  
  // 初始化应用
  const App = await import('./App.js');
  App.init();
}
```

#### 场景4：代码分割

```javascript
// 大型库按需加载
document.querySelector('#chartBtn').addEventListener('click', async () => {
  // 点击时才加载图表库
  const Chart = await import('chart.js');
  const ctx = document.getElementById('myChart');
  new Chart.default(ctx, { /* 配置 */ });
});

// 管理员功能
async function showAdminPanel() {
  // 只有管理员才加载管理模块
  const AdminModule = await import('./admin/AdminPanel.js');
  AdminModule.render();
}
```

---

## 5. Promise.allSettled()

### 5.1 基本语法

`Promise.allSettled()` 等待所有Promise完成（无论成功或失败）。

```javascript
const promises = [
  Promise.resolve('成功1'),
  Promise.reject(new Error('失败')),
  Promise.resolve('成功2')
];

const results = await Promise.allSettled(promises);
console.log(results);
// [
//   { status: 'fulfilled', value: '成功1' },
//   { status: 'rejected', reason: Error: 失败 },
//   { status: 'fulfilled', value: '成功2' }
// ]
```

### 5.2 与Promise.all的区别

```javascript
// Promise.all - 一个失败全部失败
try {
  const results = await Promise.all([
    Promise.resolve(1),
    Promise.reject(new Error('error')),
    Promise.resolve(3)
  ]);
} catch (error) {
  console.log('捕获错误:', error.message); // 捕获错误: error
}

// Promise.allSettled - 所有都完成
const results = await Promise.allSettled([
  Promise.resolve(1),
  Promise.reject(new Error('error')),
  Promise.resolve(3)
]);
// 获取所有结果，包括成功和失败的
```

### 5.3 实际应用场景

#### 场景1：批量请求

```javascript
async function fetchMultipleUsers(userIds) {
  const promises = userIds.map(id => 
    fetch(`/api/users/${id}`).then(r => r.json())
  );
  
  const results = await Promise.allSettled(promises);
  
  const users = [];
  const errors = [];
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      users.push(result.value);
    } else {
      errors.push({ id: userIds[index], error: result.reason });
    }
  });
  
  return { users, errors };
}

// 使用
const { users, errors } = await fetchMultipleUsers([1, 2, 3, 999]);
console.log('成功获取的用户:', users);
console.log('失败的请求:', errors);
```

#### 场景2：并行初始化

```javascript
async function initializeApp() {
  const results = await Promise.allSettled([
    loadConfig(),
    connectDatabase(),
    initCache(),
    loadTranslations()
  ]);
  
  const errors = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
  
  if (errors.length > 0) {
    console.warn('部分初始化失败:', errors);
    // 可以决定是否继续运行
  }
  
  const [config, db, cache, i18n] = results.map(r => 
    r.status === 'fulfilled' ? r.value : null
  );
  
  return { config, db, cache, i18n };
}
```

#### 场景3：健康检查

```javascript
async function healthCheck(services) {
  const checks = services.map(service => 
    fetch(`${service.url}/health`)
      .then(r => r.ok ? 'healthy' : 'unhealthy')
      .catch(() => 'unreachable')
  );
  
  const results = await Promise.allSettled(checks);
  
  return services.map((service, index) => ({
    name: service.name,
    status: results[index].value || 'error'
  }));
}

// 使用
const status = await healthCheck([
  { name: 'API', url: 'https://api.example.com' },
  { name: 'Auth', url: 'https://auth.example.com' },
  { name: 'Cache', url: 'https://cache.example.com' }
]);

console.log(status);
// [
//   { name: 'API', status: 'healthy' },
//   { name: 'Auth', status: 'unreachable' },
//   { name: 'Cache', status: 'healthy' }
// ]
```

---

## 6. globalThis

### 6.1 基本概念

`globalThis` 提供了一种标准的方式来获取全局对象。

```javascript
// 浏览器中
console.log(globalThis === window); // true

// Node.js中
console.log(globalThis === global); // true

// Web Worker中
console.log(globalThis === self); // true

// 通用代码
globalThis.myGlobalVar = 'hello';
console.log(globalThis.myGlobalVar); // 'hello'
```

### 6.2 实际应用场景

```javascript
// 场景1：跨环境代码
function getGlobalObject() {
  return globalThis;
}

// 场景2：polyfill
if (typeof globalThis.fetch === 'undefined') {
  globalThis.fetch = customFetchImplementation;
}

// 场景3：注册全局函数
function registerGlobalHelper(name, fn) {
  if (globalThis[name]) {
    console.warn(`全局变量 ${name} 已存在`);
    return;
  }
  globalThis[name] = fn;
}

registerGlobalHelper('formatDate', (date) => date.toISOString());

// 场景4：特性检测
function isFeatureSupported(featureName) {
  return typeof globalThis[featureName] !== 'undefined';
}

console.log(isFeatureSupported('Promise'));      // true
console.log(isFeatureSupported('Intl'));         // true
console.log(isFeatureSupported('SomeNewFeature')); // false
```

---

## 7. String.prototype.matchAll()

### 7.1 基本语法

`matchAll()` 返回一个包含所有匹配结果的迭代器。

```javascript
const text = 'test1test2test3';
const regex = /test(\d)/g;

// matchAll返回迭代器
const matches = text.matchAll(regex);

for (const match of matches) {
  console.log(match);
}
// ['test1', '1', index: 0, ...]
// ['test2', '2', index: 5, ...]
// ['test3', '3', index: 10, ...]

// 转为数组
const matchArray = [...text.matchAll(regex)];
console.log(matchArray.length); // 3
```

### 7.2 与exec循环的对比

```javascript
// 之前的写法（使用exec循环）
const regex = /test(\d)/g;
const text = 'test1test2test3';
let match;
const results = [];

while ((match = regex.exec(text)) !== null) {
  results.push(match);
}

// 使用matchAll
const results2 = [...text.matchAll(/test(\d)/g)];
```

### 7.3 实际应用场景

#### 场景1：解析模板字符串

```javascript
const template = 'Hello {{name}}, your age is {{age}}';
const regex = /\{\{(\w+)\}\}/g;

const placeholders = [...template.matchAll(regex)].map(match => ({
  full: match[0],
  key: match[1],
  index: match.index
}));

console.log(placeholders);
// [
//   { full: '{{name}}', key: 'name', index: 6 },
//   { full: '{{age}}', key: 'age', index: 32 }
// ]

// 替换占位符
function render(template, data) {
  return [...template.matchAll(/\{\{(\w+)\}\}/g)]
    .reduce((result, match) => {
      return result.replace(match[0], data[match[1]] ?? '');
    }, template);
}

console.log(render(template, { name: '张三', age: 25 }));
// 'Hello 张三, your age is 25'
```

#### 场景2：提取URL参数

```javascript
function parseQueryString(url) {
  const queryString = url.split('?')[1] || '';
  const regex = /([^&=]+)=([^&]*)/g;
  
  return Object.fromEntries(
    [...queryString.matchAll(regex)].map(match => [
      decodeURIComponent(match[1]),
      decodeURIComponent(match[2])
    ])
  );
}

const url = 'https://example.com?name=张三&age=25&city=北京';
console.log(parseQueryString(url));
// { name: '张三', age: '25', city: '北京' }
```

#### 场景3：代码高亮

```javascript
function highlightCode(code) {
  const keywords = /\b(const|let|var|function|return|if|else)\b/g;
  const strings = /'[^']*'|"[^"]*"/g;
  const numbers = /\b\d+\b/g;
  
  const matches = [
    ...[...code.matchAll(keywords)].map(m => ({ ...m, type: 'keyword' })),
    ...[...code.matchAll(strings)].map(m => ({ ...m, type: 'string' })),
    ...[...code.matchAll(numbers)].map(m => ({ ...m, type: 'number' }))
  ].sort((a, b) => a.index - b.index);
  
  return matches;
}

const code = "const x = 'hello'; const y = 42;";
console.log(highlightCode(code));
```

---

## 8. for-in顺序

ES2020规范了 `for-in` 循环的遍历顺序。

```javascript
const obj = {
  2: 'two',
  1: 'one',
  b: 'b',
  a: 'a'
};

// 顺序：整数键升序 -> 字符串键按插入顺序
for (const key in obj) {
  console.log(key);
}
// 1, 2, b, a
```

---

## 9. import.meta

### 9.1 基本概念

`import.meta` 提供关于当前模块的元信息。

```javascript
// 获取当前模块的URL
console.log(import.meta.url);
// 'file:///path/to/module.js' 或 'https://example.com/module.js'

// 在浏览器中获取当前脚本目录
const currentDir = new URL('.', import.meta.url).href;

// 在Node.js中获取__dirname等效
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

### 9.2 实际应用场景

```javascript
// 场景1：加载相对资源
async function loadJSON(filename) {
  const url = new URL(filename, import.meta.url);
  const response = await fetch(url);
  return response.json();
}

// 场景2：环境判断（Vite）
if (import.meta.env.DEV) {
  console.log('开发模式');
}

// 场景3：热更新（Vite）
if (import.meta.hot) {
  import.meta.hot.accept(() => {
    console.log('模块已更新');
  });
}
```

---

## 10. export * as ns from 'module'

### 10.1 基本语法

允许将模块的所有导出聚合为一个命名空间。

```javascript
// 之前的写法
import * as utils from './utils.js';
export { utils };

// ES2020写法
export * as utils from './utils.js';

// 使用
// import { utils } from './aggregated.js';
// utils.someFunction();
```

### 10.2 实际应用

```javascript
// index.js - 聚合多个模块
export * as array from './array-utils.js';
export * as string from './string-utils.js';
export * as object from './object-utils.js';

// 使用
// import { array, string, object } from './utils/index.js';
// array.unique([1, 2, 2, 3]);
// string.capitalize('hello');
```

---

## 总结

ES11 (ES2020) 的主要新特性：

### 可选链操作符 (?.)
- 安全地访问嵌套属性
- 支持属性、数组、方法调用
- 避免繁琐的null/undefined检查

### 空值合并操作符 (??)
- 只在null/undefined时使用默认值
- 保留其他falsy值（0, '', false）
- 支持赋值运算符 ??=

### BigInt
- 任意精度的整数
- 解决大数精度丢失问题
- 用于加密、数据库ID等场景

### 动态导入 import()
- 按需加载模块
- 返回Promise
- 支持代码分割

### Promise.allSettled()
- 等待所有Promise完成
- 获取所有结果（成功和失败）
- 适合批量操作场景

### globalThis
- 统一的全局对象访问方式
- 跨环境兼容

### String.prototype.matchAll()
- 返回所有匹配的迭代器
- 包含捕获组信息

### 其他特性
- for-in顺序规范化
- import.meta
- export * as namespace

这些特性大大提升了JavaScript的开发体验和代码安全性。
